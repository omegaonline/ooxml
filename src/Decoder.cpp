///////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2012 Rick Taylor
//
// This file is part of OOXML, the Omega Online XML library.
//
// OOXML is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OOXML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with OOXML.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////////////

#include "Decoder.h"

// These decoders only need to handle ASCII 0x01..0x7F

namespace
{
	class UTF32LEDecoder : public Decoder
	{
	public:
		UTF32LEDecoder() : m_count(0)
		{}

		unsigned char next(unsigned char c, bool& again);

	private:
		unsigned int m_count;
	};

	class UTF32BEDecoder : public Decoder
	{
	public:
		UTF32BEDecoder() : m_count(0)
		{}

		unsigned char next(unsigned char c, bool& again);

	private:
		unsigned int m_count;
	};

	class UTF16LEDecoder : public Decoder
	{
	public:
		UTF16LEDecoder() : m_cont(false)
		{}

		unsigned char next(unsigned char c, bool& again);

	private:
		bool m_cont;
	};

	class UTF16BEDecoder : public Decoder
	{
	public:
		UTF16BEDecoder() : m_cont(true)
		{}

		unsigned char next(unsigned char c, bool& again);

	private:
		bool m_cont;
	};

	class EBCDICDecoder : public Decoder
	{
	public:
		unsigned char next(unsigned char c, bool& again);
	};
}

unsigned char UTF32LEDecoder::next(unsigned char c, bool& again)
{
	again = (m_count++ != 0);

	if (m_count >= 4)
		m_count = 0;

	if (again && c != '\0')
		again = false;

	return c;
}

unsigned char UTF32BEDecoder::next(unsigned char c, bool& again)
{
	again = (m_count++ != 3);

	if (m_count >= 4)
		m_count = 0;

	if (again && c != '\0')
		again = false;

	return c;
}

unsigned char UTF16LEDecoder::next(unsigned char c, bool& again)
{
	again = m_cont;
	m_cont = !again;

	if (again && c != '\0')
		again = false;

	return c;
}

unsigned char UTF16BEDecoder::next(unsigned char c, bool& again)
{
	again = m_cont;
	m_cont = !again;

	if (again && c != '\0')
		again = false;

	return c;
}

unsigned char EBCDICDecoder::next(unsigned char c, bool& again)
{
	static const char table[256] =
	{
		0xFF,0x01,0x02,0x03,0xFF,0x09,0xFF,0x7F,0xFF,0xFF,0xFF,0x0B,0x0C,0x0D,0x0E,0x0F,
		0x10,0x11,0x12,0x13,0xFF,0x85,0x08,0x00,0x18,0x19,0xFF,0xFF,0x1C,0x1D,0x1E,0x1F,
		0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x17,0x1B,0xFF,0xFF,0xFF,0xFF,0xFF,0x05,0x06,0x07,
		0xFF,0xFF,0x16,0xFF,0xFF,0xFF,0xFF,0x04,0xFF,0xFF,0xFF,0xFF,0x14,0x15,0xFF,0x1A,
		0x20,0xA0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x2E,0x3C,0x28,0x2B,0x7C,
		0x26,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x21,0x24,0x2A,0x29,0x3B,0xAC,
		0x2D,0x2F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xA6,0x2C,0x25,0x5F,0x3E,0x3F,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x60,0x3A,0x23,0x40,0x27,0x3D,0x22,
		0xFF,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0xFF,0xFF,0xFF,0xFF,0xFF,0xB1,
		0xFF,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0x7E,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x5E,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x5B,0x5D,0xFF,0xFF,0xFF,0xFF,
		0x7B,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0xAD,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x7D,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x5C,0xFF,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	};

	again = false;
	return table[c];
}

Decoder* Decoder::create(eType type)
{
	Decoder* ret = NULL;
	switch (type)
	{
	case UTF32LE:
		ret = new (std::nothrow) UTF32LEDecoder();
		break;

	case UTF32BE:
		ret = new (std::nothrow) UTF32BEDecoder();
		break;

	case UTF16LE:
		ret = new (std::nothrow) UTF16LEDecoder();
		break;

	case UTF16BE:
		ret = new (std::nothrow) UTF16BEDecoder();
		break;

	case EBCDIC:
		ret = new (std::nothrow) EBCDICDecoder();
		break;

	default:
		return NULL;
	}

	if (!ret)
		throw "Out of memory";

	return ret;
}

