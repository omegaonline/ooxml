///////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2011 Rick Taylor
//
// This file is part of OOXML, the Omega Online XML library.
//
// OOXML is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OOXML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with OOXML.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////////////

#define TOKEN(n) set_token(pe,Tokenizer::n);

%%{
	machine xml;
	access this->m_;
	alphtype unsigned char;
	
	prepush { pre_push(); }
	
	action return { fret; }
	action append { m_token.push(m_char); }
	action entity { m_entity.push(m_char); }
	action entity_name { m_entity_name.push(m_char); }
	
	# UTF-8 validation
	utf8_cont = 0x80..0xBF;
    utf8_one_byte = 0x00..0x7F;
    utf8_two_byte_basic      = (0xC0..0xDF) utf8_cont;
    utf8_two_byte_overlong   = (0xC0..0xC1) utf8_cont;
    utf8_two_byte            = utf8_two_byte_basic - utf8_two_byte_overlong;
    utf8_three_byte_basic    = (0xE0..0xEF) utf8_cont{2};
    utf8_three_byte_overlong = 0xE0 (0x80..0x9F) utf8_cont;
    utf8_three_byte_reserved = 0xED (0xA0..0xBF) utf8_cont;  # U+D800 to U+DFFF
    utf8_three_byte          = utf8_three_byte_basic - utf8_three_byte_overlong - utf8_three_byte_reserved;
    utf8_four_byte_basic     = (0xF0..0xF4) utf8_cont{3};
    utf8_four_byte_overlong  = 0xF0 (0x80..0x8F) utf8_cont{2};
    utf8_four_byte_reserved  = 0xF4 (0x90..0xBF) utf8_cont{2};    # > U+10FFFF
    utf8_four_byte           = utf8_four_byte_basic - utf8_four_byte_overlong - utf8_four_byte_reserved;
    utf8_char                = (utf8_one_byte | utf8_two_byte | utf8_three_byte | utf8_four_byte);
	
	XMLPart       =    (0xFF 0xFE 0x00 0x00)? 0x00 0x00 0x00 0x3C @{decoder(Decoder::UTF32LE);} '?xml'   
	                   | (0x00 0x00 0xFE 0xFF)? 0x3C 0x00 0x00 0x00 @{decoder(Decoder::UTF32BE);} '?xml'
	                   | (0xFE 0xFF)? 0x00 0x3C 0x00 0x03F @{decoder(Decoder::UTF16BE);} 'xml'
	                   | (0xFF 0xFE)? 0x3C 0x00 0x03F 0x00 @{decoder(Decoder::UTF16LE);} 'xml'
	                   | 0x4C 0x6F 0x0A7 0x94 @{decoder(Decoder::EBCDIC);} 'l'
	                   | (0xEF 0xBB 0xBF)? '<?xml';

	Char          =    utf8_char - ((0x00..0x08) | 0x0B | 0x0C | (0x0E..0x1F) | (0xEF 0xBF 0xBE) | (0xEF 0xBF 0xBF));
	                   
	S             =    (0x20 | 0x9 | 0xD | 0xA)+;
	Eq            =    S? '=' S?;
	VersionNum    =    ('1.' [0-9]+) $append;
	VersionInfo   =    S 'version' Eq @{m_token.clear();} ("'" VersionNum "'" | '"' VersionNum '"');
	EncName       =    ([a-zA-Z] ([a-zA-Z0-9._] | '-')*) $append;
	EncodingDecl  =    S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" ) @{encoding(pe);};
	SDDecl        =    S 'standalone' Eq (("'" ('yes' @{TOKEN(DocumentStandalone)} | 'no') "'") | ('"' ('yes' @{TOKEN(DocumentStandalone)} | 'no') '"'));
		                   	
	XMLDecl       =    XMLPart @{fcall XMLDecl_i;};
	XMLDecl_i    :=    VersionInfo @{TOKEN(DocumentVersion)} EncodingDecl? SDDecl? S? '?>' @{fret;};
	
	Comment       =    '<!--' @{fcall Comment_i;};
	Comment_i    :=    ((Char - '-') | ('-' (Char - '-')))* $append '-->' @{set_token(pe,Tokenizer::Comment,1); fret;};
	
	NameStartChar =    [a-zA-Z:_]
	                   | 0xC3 (utf8_cont - (0x97 | 0xB7))                          # [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#xFF]
	                   | (0xC4..0xCB) utf8_cont                                    # [#x100-#x2FF]
	                   | 0xCD (0xB0..0xBD | 0xBF)                                  # [#x370-#x37D]
	                   | (0xCE..0xDF) utf8_cont                                    # [#x37F-#x7FF]
	                   | (((0xE0..0xE1) utf8_cont{2} ) - utf8_three_byte_overlong) # [#x800-#x1FFF]
	                   | 0xE2 0x80 (0x8C | 0x8D)                                   # [#x200C-#x200D]
	                   | 0xE2 (0x81 (0xB0..0xBF) | (0x82..0x88) utf8_cont | 0x89 (0x80..0x8F)) # [#x2070-#x218F]
	                   | 0xE2 ((0xB0..0xBE) utf8_cont | 0xBF (0x80..0xAF))         # [#x2C00-#x2FEF]
	                   | 0xE3 (0x80 (0x81..0xBF) | (0x81..0xBF) utf8_cont)         # [#x3001-#x3FFF]
	                   | (0xE4..0xEC) utf8_cont{2} | 0xED (0x80..0x9F) utf8_cont   # [#x4000-#xD7FF]
	                   | 0xEF ((0xA4..0xB6) utf8_cont | 0xB7 (0x80..0x87))         # [#xF900-#xFDCF]
	                   | 0xEF (0xB7 (0xB0..0xBF) | (0xB8..0xBF) utf8_cont)         # [#xFDF0-#xFFFD]
	                   | utf8_four_byte;                                            # [#x10000-#xEFFFF]
	 
	NameChar      =    NameStartChar | "-" | "." | [0-9]
	                   | 0xC2 0xB7                          #  #xB7
	                   | 0xCC utf8_cont | 0xCD (0x80..0xAF) # [#x0300-#x036F]
	                   | 0xE2 (0x80 0xBF | 0x81 0x80);      # [#x203F-#x2040]
		  
	Name          =    NameStartChar (NameChar)*;
	NCName        =    (Name -- ':');
	
	LocalPart     =    NCName;
	Prefix        =    NCName;
	UnprefixedName =   LocalPart;
	PrefixedName  =    Prefix ':' LocalPart;
	QName         =    PrefixedName | UnprefixedName;
	
	PrefixedAttName =  'xmlns:' NCName;
	DefaultAttName =   'xmlns';
	NSAttName     =    PrefixedAttName | DefaultAttName;
	
	PITarget      =    Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'));
	PI            =    '<?' PITarget $append %{TOKEN(PiTarget)} (S (Char* -- '?>') $append )? '?>' @{set_token(pe,Tokenizer::PiData,1);};
		
	Misc          =    Comment | PI | S;
	
	SystemLiteral =    ('"' (Char - '"')* ${m_system.push(m_char);} '"') | ("'" (Char - "'")* ${m_system.push(m_char);} "'");
	PubidChar     =    0x20 | 0xD | 0xA | [a-zA-Z0-9] | '-' | ['()+,./:=?;!*#@$_%];
	PubidLiteral  =    '"' PubidChar* ${m_public.push(m_char);} '"' | "'" (PubidChar - "'")* ${m_public.push(m_char);} "'";
	ExternalID    =    'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral;
	StringType    =    'CDATA';
	TokenizedType =    'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS';
	NotationType  =    'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')';
	Nmtoken       =    (NameChar)+;
	Enumeration   =    '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')';
	EnumeratedType =   NotationType | Enumeration;
	AttType       =    StringType | TokenizedType | EnumeratedType;
	
	CharRef       =    '&#' [0-9]+ $entity ';' @{subst_char(10);} | '&#x' [0-9a-fA-F]+ $entity ';' @{subst_char(16);};
	EntityRef     =    '&' Name $entity ';';
		
	DAReference   =    CharRef | EntityRef;
	DeclAttValue  =    '"' ((Char - [<&"]) | DAReference)*  '"' | "'" ((Char - [<&']) | DAReference)* "'";
	DefaultDecl   =    '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? DeclAttValue);
	AttDef        =    S (QName | NSAttName) S AttType S DefaultDecl;
	AttlistDecl   =    '<!ATTLIST' S QName AttDef* S? '>';
	PEReference   =    '%' Name $entity ';' @{ if (subst_pentity()) fcall extParsedEnt; };
	EVReference   =    CharRef | EntityRef @{bypass_entity();};
	EntityValue   =    '"' ((Char - [%&"]) $append | PEReference | EVReference)* '"' |  "'" ((Char - [%&']) $append | PEReference | EVReference)* "'";
	NDataDecl     =    S 'NDATA' S Name $entity;
	EntityDef     =    EntityValue | (ExternalID NDataDecl?);
	
	GEDecl        =    '<!ENTITY' S Name $entity_name S EntityDef S? '>' @{general_entity();};
	PEDef         =    EntityValue | ExternalID;
	PEDecl        =    '<!ENTITY' S '%' S Name $entity_name S PEDef S? '>' @{param_entity();};
	EntityDecl    =    GEDecl | PEDecl;
	PublicID      =    'PUBLIC' S PubidLiteral;
	NotationDecl  =    '<!NOTATION' S Name S (ExternalID | PublicID) S? '>';
	DeclSep       =    PEReference | S;   
	
	AttReference  =    CharRef | EntityRef @{if (subst_attr_entity()) fcall AttValueEnt;};
	AttValue     :=    ('"' ((Char - [<&"]) $append | AttReference)* '"' | "'" ((Char - [<&']) $append | AttReference)* "'") @{TOKEN(AttributeValue);fret;};
	Attribute     =    (NSAttName | QName) $append Eq @{TOKEN(AttributeName);fcall AttValue;};
	
	CharData      =    ((Char - [<&])* -- ']]>') $append %{set_token(pe,Tokenizer::Text,0,false);};
	
	CDSect        =    '<![CDATA[' @{fcall CDSect_i;};
	CDSect_i     :=    (Char* -- ']]>') $append ']]>' @{set_token(pe,Tokenizer::CData,2);fret;};

	ch_or_seq     =    '(' @{fcall ch_or_seq1;};
	cp            =    (QName | ch_or_seq) ('?' | '*' | '+')?;
	choice        =    S? cp ( S? '|' S? cp )+ S?;
	seq           =    S? cp ( S? ',' S? cp )* S?;	
	ch_or_seq1   :=    (choice | seq) ')' @return;
	children      =    '(' S? (choice | seq) ')' ('?' | '*' | '+')?;
	Mixed         =    '(' S? '#PCDATA' ((S? '|' S? QName)* S? ')*' | S? ')');
		
	contentspec   =    'EMPTY' | 'ANY' | Mixed | children;
	elementdecl   =    '<!ELEMENT' S QName S contentspec S? '>';
	markupdecl    =    elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment ;
	intSubset     =    (markupdecl | DeclSep)*;
	
	CReference    =    CharRef | EntityRef @{unsigned int t=subst_content_entity();if (t==1) fcall intParsedEnt; else if (t==2) fcall extParsedEnt;};	
	ETag          =    '</' QName $append %{TOKEN(ElementEnd)} S? '>';
	element       =    '<' QName $append %{TOKEN(ElementStart)} (S Attribute)* S? ('/>' @{TOKEN(ElementEnd)} | '>' @{fcall content_i;});
	content       =    CharData? ((element | CDSect | PI | Comment | CReference ) CharData?)*;
	content_i    :=    content ETag @return;    
	
	Ignore        =    Char* -- ('<![' | ']]>');
	
	ignoreSectContents = Ignore ('<![' @{fcall ignoreSectContents_1;} ']]>' Ignore)*;
	ignoreSectContents_1 := ignoreSectContents @return;
	
	includeSect   =    '<![' S? 'INCLUDE' S? '[' @{fcall extSubsetDecl_1;} ']]>';
	ignoreSect    =    '<![' S? 'IGNORE' S? '[' ignoreSectContents ']]>';
	
	conditionalSect =  includeSect | ignoreSect;
	extSubsetDecl =    (markupdecl | conditionalSect | DeclSep)*;
	extSubsetDecl_1 := extSubsetDecl %return;
			
	TextDecl      =    XMLPart VersionInfo? %{m_token.clear();} EncodingDecl S? '?>';
	
	action ext_return { printf("entity_return\n"); entity_return(); fret;}
	extSubset    :=    TextDecl? extSubsetDecl %{TOKEN(DocTypeEnd)} %ext_return %{fret;};
	extParsedEnt :=    TextDecl? content %ext_return;
	intParsedEnt :=    content >{printf("intParsedEnt\n");} %ext_return;
	AttValueEnt  :=    ((Char - [<&]) $append | AttReference)* %ext_return;
	
	doctypedecl   =    '<!DOCTYPE' @{fcall doctypedecl_i;};
	doctypedecl_i:=    S QName $append %{TOKEN(DocTypeStart)} (S ExternalID @{external_doctype();})? S? ('[' intSubset ']' S?)? '>' @{ if (do_doctype()) fcall extSubset; else {TOKEN(DocTypeEnd);fret;}};
	prolog        =    XMLDecl? Misc* (doctypedecl Misc*)?;
	document      =    prolog element Misc*;
 
	dump := PI;
	
	main := document;
}%%

#include "../src/Tokenizer.h"

%% write data;

void Tokenizer::do_init()
{
	%% write init;
}

Tokenizer::TokenType Tokenizer::next_token(OOBase::String& strToken, int verbose)
{
	// Ragel variables
	Tokenizer&      p   = *this;
	const EndOfFile eof = EndOfFile();
	ParseState      pe(strToken);
			
	try
	{
		%% write exec;
		
		if (!pe.m_halt && m_cs >= %%{ write first_final; }%%)
			pe.m_type = Tokenizer::End;
			
		if (verbose >= 2)
			printf("m_cs=%d,t=%d,%s\n",m_cs,pe.m_type,strToken.c_str());
	
		if (verbose >= 1 && pe.m_type == Tokenizer::Error)
			printf("Syntax error at %s, line %lu, col %lu\n",m_io->m_fname.c_str(),m_io->m_line,m_io->m_col);
	}
	catch (const char* e)
	{
		if (verbose >= 1)
			printf("%s at %s, line %lu, col %lu\n",e,m_io->m_fname.c_str(),m_io->m_line,m_io->m_col);
	}
	
	return pe.m_type;
}
